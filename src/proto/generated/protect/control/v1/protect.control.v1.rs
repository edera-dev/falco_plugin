// @generated
// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Zone {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<ZoneSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<ZoneStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneSpec {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// If not specified, defaults to the daemon default kernel.
    #[prost(message, optional, tag="2")]
    pub kernel: ::core::option::Option<OciImageSpec>,
    /// If not specified, defaults to the daemon default initrd.
    #[prost(message, optional, tag="3")]
    pub initrd: ::core::option::Option<OciImageSpec>,
    #[prost(message, optional, tag="4")]
    pub kernel_options: ::core::option::Option<KernelOptionsSpec>,
    #[prost(message, optional, tag="5")]
    pub initial_resources: ::core::option::Option<ZoneResourcesSpec>,
    #[prost(message, repeated, tag="6")]
    pub annotations: ::prost::alloc::vec::Vec<AnnotationSpec>,
    #[prost(message, repeated, tag="7")]
    pub devices: ::prost::alloc::vec::Vec<DeviceReferenceSpec>,
    #[prost(message, optional, tag="8")]
    pub network_options: ::core::option::Option<ZoneNetworkOptionsSpec>,
    #[prost(message, optional, tag="9")]
    pub virtualization_options: ::core::option::Option<ZoneVirtualizationOptionsSpec>,
    #[prost(message, optional, tag="10")]
    pub scratch_disk: ::core::option::Option<ZoneScratchDiskSpec>,
    #[prost(message, repeated, tag="11")]
    pub addons: ::prost::alloc::vec::Vec<OciImageSpec>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneResourcesSpec {
    #[prost(uint64, tag="1")]
    pub max_memory: u64,
    #[prost(uint64, tag="6")]
    pub min_memory: u64,
    #[prost(uint64, tag="2")]
    pub target_memory: u64,
    #[prost(uint32, tag="3")]
    pub max_cpus: u32,
    #[prost(uint32, tag="7")]
    pub min_cpus: u32,
    #[prost(uint32, tag="4")]
    pub target_cpus: u32,
    #[prost(enumeration="ZoneResourceAdjustmentPolicy", tag="5")]
    pub adjustment_policy: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KernelModuleParameter {
    #[prost(string, tag="1")]
    pub module: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub parameter: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KernelSysctlParameter {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelOptionsSpec {
    #[prost(bool, tag="1")]
    pub verbose: bool,
    #[prost(string, tag="2")]
    pub cmdline_append: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub cmdline: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="4")]
    pub modules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="5")]
    pub module_parameters: ::prost::alloc::vec::Vec<KernelModuleParameter>,
    #[prost(message, repeated, tag="6")]
    pub sysctl_parameters: ::prost::alloc::vec::Vec<KernelSysctlParameter>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneNetworkOptionsSpec {
    #[prost(string, tag="1")]
    pub assume_network_reservation: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub retain_network_reservation: bool,
    #[prost(message, optional, tag="3")]
    pub dns_config: ::core::option::Option<ZoneNetworkOptionsDnsSpec>,
    #[prost(enumeration="ZoneNetworkBackend", tag="4")]
    pub backend: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneNetworkOptionsDnsSpec {
    #[prost(string, repeated, tag="3")]
    pub nameservers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="4")]
    pub searches: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="5")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneVirtualizationOptionsSpec {
    #[prost(enumeration="ZoneVirtualizationBackend", tag="1")]
    pub backend: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciImageSpec {
    #[prost(string, tag="1")]
    pub digest: ::prost::alloc::string::String,
    #[prost(enumeration="OciImageFormat", tag="2")]
    pub format: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciImageMetadata {
    #[prost(bytes="vec", tag="1")]
    pub manifest: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub config: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciImageInfo {
    #[prost(string, tag="1")]
    pub digest: ::prost::alloc::string::String,
    #[prost(enumeration="OciImageFormat", tag="2")]
    pub format: i32,
    #[prost(string, repeated, tag="3")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="4")]
    pub metadata: ::core::option::Option<OciImageMetadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessSpec {
    #[prost(message, repeated, tag="1")]
    pub environment: ::prost::alloc::vec::Vec<EnvironmentVariableSpec>,
    #[prost(string, repeated, tag="2")]
    pub command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub working_directory: ::prost::alloc::string::String,
    #[prost(bool, tag="4")]
    pub tty: bool,
    #[prost(message, optional, tag="5")]
    pub terminal_size: ::core::option::Option<TerminalSize>,
    #[prost(message, optional, tag="6")]
    pub user: ::core::option::Option<IdOrNameValue>,
    #[prost(message, optional, tag="7")]
    pub group: ::core::option::Option<IdOrNameValue>,
    #[prost(bool, tag="8")]
    pub stdin: bool,
    #[prost(bool, tag="9")]
    pub stdout: bool,
    #[prost(bool, tag="10")]
    pub stderr: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MountSpec {
    #[prost(string, tag="1")]
    pub host_path: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub target_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EnvironmentVariableSpec {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AnnotationSpec {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceReferenceSpec {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkloadBlockDeviceSpec {
    #[prost(string, tag="1")]
    pub target_path: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub device_path: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub mount_options: ::core::option::Option<BlockDeviceMountOptions>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockDeviceMountOptions {
    #[prost(bool, tag="1")]
    pub readonly: bool,
    #[prost(string, tag="2")]
    pub permissions: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneStatus {
    #[prost(enumeration="ZoneState", tag="1")]
    pub state: i32,
    #[prost(message, optional, tag="2")]
    pub network_status: ::core::option::Option<ZoneNetworkStatus>,
    #[prost(message, optional, tag="3")]
    pub exit_status: ::core::option::Option<ZoneExitStatus>,
    #[prost(message, optional, tag="4")]
    pub error_status: ::core::option::Option<ZoneErrorStatus>,
    #[prost(string, tag="5")]
    pub host: ::prost::alloc::string::String,
    #[prost(uint32, tag="6")]
    pub domid: u32,
    #[prost(message, optional, tag="7")]
    pub resource_status: ::core::option::Option<ZoneResourceStatus>,
    #[prost(message, optional, tag="8")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag="9")]
    pub device_status: ::core::option::Option<ZoneDeviceStatus>,
    #[prost(message, optional, tag="10")]
    pub ready_at: ::core::option::Option<::pbjson_types::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneNetworkIp {
    #[prost(enumeration="ZoneNetworkIpVersion", tag="1")]
    pub version: i32,
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub gateway: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneNetworkRoute {
    #[prost(enumeration="ZoneNetworkIpVersion", tag="1")]
    pub version: i32,
    #[prost(string, tag="2")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub destination: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub gateway: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub output_interface: ::prost::alloc::string::String,
    #[prost(uint32, tag="6")]
    pub scope: u32,
    #[prost(uint32, tag="7")]
    pub table: u32,
    #[prost(uint32, tag="8")]
    pub protocol: u32,
    #[prost(uint32, tag="9")]
    pub kind: u32,
    #[prost(string, tag="10")]
    pub pref_source: ::prost::alloc::string::String,
}
/// Represents a command like
/// `ip neigh add 168.254.1.1 lladdr 06:26:7a:34:d9:c5 dev eth0 nud permanent`
/// See `man ip-neighbor(8)` for details.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneNetworkNeighborEntry {
    #[prost(enumeration="ZoneNetworkIpVersion", tag="1")]
    pub version: i32,
    #[prost(string, tag="2")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub link_layer_address: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub attached_interface: ::prost::alloc::string::String,
    #[prost(enumeration="ZoneNetworkNudMode", tag="5")]
    pub unreachability_detection: i32,
    #[prost(uint32, tag="6")]
    pub kind: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneNetworkConfig {
    #[prost(message, repeated, tag="1")]
    pub interfaces: ::prost::alloc::vec::Vec<ZoneNetworkInterfaceConfig>,
    #[prost(message, repeated, tag="2")]
    pub routes: ::prost::alloc::vec::Vec<ZoneNetworkRoute>,
    #[prost(message, repeated, tag="3")]
    pub neighbors: ::prost::alloc::vec::Vec<ZoneNetworkNeighborEntry>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneNetworkInterfaceConfig {
    #[prost(string, tag="1")]
    pub zone_interface: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub zone_mac: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="3")]
    pub ips: ::prost::alloc::vec::Vec<ZoneNetworkIp>,
    #[prost(uint32, tag="4")]
    pub mtu: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneNetworkInterfaceStatus {
    #[prost(string, tag="1")]
    pub host_interface: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub zone_interface: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub zone_mac: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub ips: ::prost::alloc::vec::Vec<ZoneNetworkIp>,
    #[prost(uint32, tag="5")]
    pub mtu: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneNetworkStatus {
    #[prost(message, repeated, tag="1")]
    pub interfaces: ::prost::alloc::vec::Vec<ZoneNetworkInterfaceStatus>,
    #[prost(message, repeated, tag="2")]
    pub routes: ::prost::alloc::vec::Vec<ZoneNetworkRoute>,
    #[prost(message, repeated, tag="3")]
    pub neighbors: ::prost::alloc::vec::Vec<ZoneNetworkNeighborEntry>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneExitStatus {
    #[prost(int32, tag="1")]
    pub code: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneErrorStatus {
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneResourceStatus {
    #[prost(message, optional, tag="1")]
    pub active_resources: ::core::option::Option<ZoneResourcesSpec>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricNode {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub value: ::core::option::Option<::pbjson_types::Value>,
    #[prost(enumeration="MetricFormat", tag="3")]
    pub format: i32,
    #[prost(message, repeated, tag="4")]
    pub children: ::prost::alloc::vec::Vec<MetricNode>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TerminalSize {
    #[prost(uint32, tag="1")]
    pub rows: u32,
    #[prost(uint32, tag="2")]
    pub columns: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IdOrNameValue {
    #[prost(oneof="id_or_name_value::IdOrName", tags="1, 2")]
    pub id_or_name: ::core::option::Option<id_or_name_value::IdOrName>,
}
/// Nested message and enum types in `IdOrNameValue`.
pub mod id_or_name_value {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum IdOrName {
        #[prost(uint32, tag="1")]
        Id(u32),
        #[prost(string, tag="2")]
        Name(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkReservation {
    #[prost(string, tag="1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub ipv4: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub ipv6: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub mac: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub gateway_ipv4: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub gateway_ipv6: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub gateway_mac: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadSpec {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub image: ::core::option::Option<OciImageSpec>,
    #[prost(message, optional, tag="4")]
    pub process: ::core::option::Option<ProcessSpec>,
    #[prost(message, repeated, tag="5")]
    pub annotations: ::prost::alloc::vec::Vec<AnnotationSpec>,
    #[prost(message, repeated, tag="6")]
    pub mounts: ::prost::alloc::vec::Vec<MountSpec>,
    #[prost(message, optional, tag="7")]
    pub security: ::core::option::Option<WorkloadSecuritySpec>,
    #[prost(message, repeated, tag="8")]
    pub scratch_mount: ::prost::alloc::vec::Vec<WorkloadScratchMount>,
    #[prost(message, repeated, tag="9")]
    pub cgroup_limits: ::prost::alloc::vec::Vec<CgroupLimit>,
    #[prost(string, tag="10")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="11")]
    pub block_devices: ::prost::alloc::vec::Vec<WorkloadBlockDeviceSpec>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CgroupLimit {
    #[prost(string, tag="1")]
    pub limit_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkloadScratchMount {
    #[prost(string, tag="1")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkloadSecuritySpec {
    #[prost(bool, tag="1")]
    pub strict_user_namespace: bool,
    #[prost(string, repeated, tag="2")]
    pub raise_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="3")]
    pub raise_ambient_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="4")]
    pub drop_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="5")]
    pub privileged: bool,
    #[prost(bool, tag="6")]
    pub disable_all_namespaces: bool,
    #[prost(enumeration="ProcessNamespace", repeated, tag="7")]
    pub disable_namespaces: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag="8")]
    pub read_only_rootfs: bool,
    #[prost(bool, tag="9")]
    pub no_new_privs: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadStatus {
    #[prost(enumeration="WorkloadState", tag="1")]
    pub state: i32,
    #[prost(message, optional, tag="2")]
    pub exit_status: ::core::option::Option<WorkloadExitStatus>,
    #[prost(message, optional, tag="3")]
    pub error_status: ::core::option::Option<WorkloadErrorStatus>,
    #[prost(message, optional, tag="4")]
    pub block_device_status: ::core::option::Option<WorkloadBlockDeviceStatus>,
    #[prost(message, optional, tag="5")]
    pub mount_status: ::core::option::Option<WorkloadMountStatus>,
    #[prost(message, optional, tag="6")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkloadBlockDeviceInfo {
    #[prost(uint32, tag="1")]
    pub block_index: u32,
    #[prost(uint64, tag="2")]
    pub device_id: u64,
    #[prost(string, tag="4")]
    pub device: ::prost::alloc::string::String,
    #[prost(bool, tag="5")]
    pub loop_dev: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadBlockDeviceStatus {
    #[prost(message, repeated, tag="1")]
    pub devices: ::prost::alloc::vec::Vec<WorkloadBlockDeviceInfo>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkloadMountInfo {
    #[prost(string, tag="2")]
    pub tag: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub host_path: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub target_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadMountStatus {
    #[prost(message, repeated, tag="2")]
    pub mounts: ::prost::alloc::vec::Vec<WorkloadMountInfo>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkloadExitStatus {
    #[prost(int32, tag="1")]
    pub code: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkloadErrorStatus {
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Workload {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<WorkloadSpec>,
    #[prost(message, optional, tag="3")]
    pub status: ::core::option::Option<WorkloadStatus>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HostCpuTopologyInfo {
    #[prost(uint32, tag="1")]
    pub core: u32,
    #[prost(uint32, tag="2")]
    pub socket: u32,
    #[prost(uint32, tag="3")]
    pub node: u32,
    #[prost(uint32, tag="4")]
    pub thread: u32,
    #[prost(enumeration="HostCpuTopologyClass", tag="5")]
    pub class: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OciImageProgress {
    #[prost(enumeration="OciImageProgressPhase", tag="1")]
    pub phase: i32,
    #[prost(message, repeated, tag="2")]
    pub layers: ::prost::alloc::vec::Vec<OciImageProgressLayer>,
    #[prost(message, optional, tag="3")]
    pub indication: ::core::option::Option<OciImageProgressIndication>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciImageProgressLayer {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration="OciImageProgressLayerPhase", tag="2")]
    pub phase: i32,
    #[prost(message, optional, tag="3")]
    pub indication: ::core::option::Option<OciImageProgressIndication>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciImageProgressIndication {
    #[prost(oneof="oci_image_progress_indication::Indication", tags="1, 2, 3, 4")]
    pub indication: ::core::option::Option<oci_image_progress_indication::Indication>,
}
/// Nested message and enum types in `OciImageProgressIndication`.
pub mod oci_image_progress_indication {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Indication {
        #[prost(message, tag="1")]
        Bar(super::OciImageProgressIndicationBar),
        #[prost(message, tag="2")]
        Spinner(super::OciImageProgressIndicationSpinner),
        #[prost(message, tag="3")]
        Hidden(super::OciImageProgressIndicationHidden),
        #[prost(message, tag="4")]
        Completed(super::OciImageProgressIndicationCompleted),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciImageProgressIndicationBar {
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub current: u64,
    #[prost(uint64, tag="3")]
    pub total: u64,
    #[prost(bool, tag="4")]
    pub is_bytes: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciImageProgressIndicationSpinner {
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciImageProgressIndicationHidden {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciImageProgressIndicationCompleted {
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub total: u64,
    #[prost(bool, tag="3")]
    pub is_bytes: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceInfo {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub claimed: bool,
    #[prost(string, tag="3")]
    pub owner_zone: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneScratchDiskSpec {
    #[prost(oneof="zone_scratch_disk_spec::Backend", tags="1, 2")]
    pub backend: ::core::option::Option<zone_scratch_disk_spec::Backend>,
}
/// Nested message and enum types in `ZoneScratchDiskSpec`.
pub mod zone_scratch_disk_spec {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Backend {
        #[prost(message, tag="1")]
        Image(super::ZoneScratchDiskSpecImage),
        #[prost(message, tag="2")]
        Block(super::ZoneScratchDiskSpecStaticBlock),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneScratchDiskSpecImage {
    #[prost(uint64, tag="1")]
    pub size: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneScratchDiskSpecStaticBlock {
    #[prost(string, tag="1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub device: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneDeviceStatus {
    #[prost(message, repeated, tag="1")]
    pub disks: ::prost::alloc::vec::Vec<ZoneDiskStatus>,
    #[prost(message, optional, tag="2")]
    pub mount: ::core::option::Option<ZoneMountStatus>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneDiskStatus {
    #[prost(string, tag="1")]
    pub zone_block_device: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub host_block_device: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub host_image_file: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub filesystem_type: ::prost::alloc::string::String,
    #[prost(enumeration="ZoneDiskStatusDiskPurpose", tag="5")]
    pub purpose: i32,
    #[prost(bool, tag="6")]
    pub delete: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneMountStatus {
    #[prost(uint64, tag="1")]
    pub device_id: u64,
    #[prost(string, tag="2")]
    pub host_path: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub tag: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciRegistryUsernamePassword {
    /// username to provide, empty means no username.
    #[prost(string, tag="1")]
    pub username: ::prost::alloc::string::String,
    /// password to provide, empty means no password.
    #[prost(string, tag="2")]
    pub password: ::prost::alloc::string::String,
}
/// OCI registry authentication
/// There are many ways this can work:
/// 1. username/password:
///     a. by providing username/password directly
///     b. by providing an auth string which is base64 encoded username:password
/// 2. an identity token: provide one token to the server to get another token which is the real token
/// 3. a registry token: an exact, specific registry token to pass to the service
/// We support all of them because that's what Kubernetes passes to us.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OciRegistryAuthentication {
    #[prost(oneof="oci_registry_authentication::AuthenticationMethod", tags="1, 2, 3, 4")]
    pub authentication_method: ::core::option::Option<oci_registry_authentication::AuthenticationMethod>,
}
/// Nested message and enum types in `OciRegistryAuthentication`.
pub mod oci_registry_authentication {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum AuthenticationMethod {
        /// username/password to login to the registry.
        #[prost(message, tag="1")]
        UsernamePassword(super::OciRegistryUsernamePassword),
        /// base64-encoded string of username:password representing basic authorization header
        #[prost(string, tag="2")]
        RawBasicAuth(::prost::alloc::string::String),
        /// bearer token to provide to get a short-lived token
        #[prost(string, tag="3")]
        IdentityToken(::prost::alloc::string::String),
        /// an exact bearer access token
        #[prost(string, tag="4")]
        RegistryToken(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneResourceAdjustmentPolicy {
    Unknown = 0,
    Static = 1,
    Dynamic = 2,
}
impl ZoneResourceAdjustmentPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ZONE_RESOURCE_ADJUSTMENT_POLICY_UNKNOWN",
            Self::Static => "ZONE_RESOURCE_ADJUSTMENT_POLICY_STATIC",
            Self::Dynamic => "ZONE_RESOURCE_ADJUSTMENT_POLICY_DYNAMIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZONE_RESOURCE_ADJUSTMENT_POLICY_UNKNOWN" => Some(Self::Unknown),
            "ZONE_RESOURCE_ADJUSTMENT_POLICY_STATIC" => Some(Self::Static),
            "ZONE_RESOURCE_ADJUSTMENT_POLICY_DYNAMIC" => Some(Self::Dynamic),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneNetworkBackend {
    Default = 0,
    None = 1,
    External = 2,
    Passthrough = 3,
}
impl ZoneNetworkBackend {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "ZONE_NETWORK_BACKEND_DEFAULT",
            Self::None => "ZONE_NETWORK_BACKEND_NONE",
            Self::External => "ZONE_NETWORK_BACKEND_EXTERNAL",
            Self::Passthrough => "ZONE_NETWORK_BACKEND_PASSTHROUGH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZONE_NETWORK_BACKEND_DEFAULT" => Some(Self::Default),
            "ZONE_NETWORK_BACKEND_NONE" => Some(Self::None),
            "ZONE_NETWORK_BACKEND_EXTERNAL" => Some(Self::External),
            "ZONE_NETWORK_BACKEND_PASSTHROUGH" => Some(Self::Passthrough),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneVirtualizationBackend {
    Unknown = 0,
    Pv = 1,
    Pvh = 2,
    Automatic = 3,
}
impl ZoneVirtualizationBackend {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ZONE_VIRTUALIZATION_BACKEND_UNKNOWN",
            Self::Pv => "ZONE_VIRTUALIZATION_BACKEND_PV",
            Self::Pvh => "ZONE_VIRTUALIZATION_BACKEND_PVH",
            Self::Automatic => "ZONE_VIRTUALIZATION_BACKEND_AUTOMATIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZONE_VIRTUALIZATION_BACKEND_UNKNOWN" => Some(Self::Unknown),
            "ZONE_VIRTUALIZATION_BACKEND_PV" => Some(Self::Pv),
            "ZONE_VIRTUALIZATION_BACKEND_PVH" => Some(Self::Pvh),
            "ZONE_VIRTUALIZATION_BACKEND_AUTOMATIC" => Some(Self::Automatic),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessNamespace {
    Mount = 0,
    Uts = 1,
    Ipc = 2,
    User = 3,
    Pid = 4,
    Net = 5,
    Cgroup = 6,
    Time = 7,
}
impl ProcessNamespace {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Mount => "PROCESS_NAMESPACE_MOUNT",
            Self::Uts => "PROCESS_NAMESPACE_UTS",
            Self::Ipc => "PROCESS_NAMESPACE_IPC",
            Self::User => "PROCESS_NAMESPACE_USER",
            Self::Pid => "PROCESS_NAMESPACE_PID",
            Self::Net => "PROCESS_NAMESPACE_NET",
            Self::Cgroup => "PROCESS_NAMESPACE_CGROUP",
            Self::Time => "PROCESS_NAMESPACE_TIME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROCESS_NAMESPACE_MOUNT" => Some(Self::Mount),
            "PROCESS_NAMESPACE_UTS" => Some(Self::Uts),
            "PROCESS_NAMESPACE_IPC" => Some(Self::Ipc),
            "PROCESS_NAMESPACE_USER" => Some(Self::User),
            "PROCESS_NAMESPACE_PID" => Some(Self::Pid),
            "PROCESS_NAMESPACE_NET" => Some(Self::Net),
            "PROCESS_NAMESPACE_CGROUP" => Some(Self::Cgroup),
            "PROCESS_NAMESPACE_TIME" => Some(Self::Time),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneState {
    Unknown = 0,
    Creating = 1,
    Created = 2,
    Ready = 3,
    Exited = 4,
    Destroying = 5,
    Destroyed = 6,
    Failed = 7,
}
impl ZoneState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ZONE_STATE_UNKNOWN",
            Self::Creating => "ZONE_STATE_CREATING",
            Self::Created => "ZONE_STATE_CREATED",
            Self::Ready => "ZONE_STATE_READY",
            Self::Exited => "ZONE_STATE_EXITED",
            Self::Destroying => "ZONE_STATE_DESTROYING",
            Self::Destroyed => "ZONE_STATE_DESTROYED",
            Self::Failed => "ZONE_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZONE_STATE_UNKNOWN" => Some(Self::Unknown),
            "ZONE_STATE_CREATING" => Some(Self::Creating),
            "ZONE_STATE_CREATED" => Some(Self::Created),
            "ZONE_STATE_READY" => Some(Self::Ready),
            "ZONE_STATE_EXITED" => Some(Self::Exited),
            "ZONE_STATE_DESTROYING" => Some(Self::Destroying),
            "ZONE_STATE_DESTROYED" => Some(Self::Destroyed),
            "ZONE_STATE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneNetworkIpVersion {
    Unknown = 0,
    V4 = 1,
    V6 = 2,
}
impl ZoneNetworkIpVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ZONE_NETWORK_IP_VERSION_UNKNOWN",
            Self::V4 => "ZONE_NETWORK_IP_VERSION_V4",
            Self::V6 => "ZONE_NETWORK_IP_VERSION_V6",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZONE_NETWORK_IP_VERSION_UNKNOWN" => Some(Self::Unknown),
            "ZONE_NETWORK_IP_VERSION_V4" => Some(Self::V4),
            "ZONE_NETWORK_IP_VERSION_V6" => Some(Self::V6),
            _ => None,
        }
    }
}
/// NUD stands for Neighbor Unreachability Detection
/// and signals how or if neighbor mapping entries will be autopruned.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneNetworkNudMode {
    Permanent = 0,
    Noarp = 1,
    /// TODO(bleggett) there are more modes but we don't care about them.
    Reachable = 2,
}
impl ZoneNetworkNudMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Permanent => "ZONE_NETWORK_NUD_MODE_PERMANENT",
            Self::Noarp => "ZONE_NETWORK_NUD_MODE_NOARP",
            Self::Reachable => "ZONE_NETWORK_NUD_MODE_REACHABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZONE_NETWORK_NUD_MODE_PERMANENT" => Some(Self::Permanent),
            "ZONE_NETWORK_NUD_MODE_NOARP" => Some(Self::Noarp),
            "ZONE_NETWORK_NUD_MODE_REACHABLE" => Some(Self::Reachable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetricFormat {
    Unknown = 0,
    Bytes = 1,
    Integer = 2,
    DurationSeconds = 3,
    Percent = 4,
}
impl MetricFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "METRIC_FORMAT_UNKNOWN",
            Self::Bytes => "METRIC_FORMAT_BYTES",
            Self::Integer => "METRIC_FORMAT_INTEGER",
            Self::DurationSeconds => "METRIC_FORMAT_DURATION_SECONDS",
            Self::Percent => "METRIC_FORMAT_PERCENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "METRIC_FORMAT_UNKNOWN" => Some(Self::Unknown),
            "METRIC_FORMAT_BYTES" => Some(Self::Bytes),
            "METRIC_FORMAT_INTEGER" => Some(Self::Integer),
            "METRIC_FORMAT_DURATION_SECONDS" => Some(Self::DurationSeconds),
            "METRIC_FORMAT_PERCENT" => Some(Self::Percent),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkloadState {
    Unknown = 0,
    Creating = 1,
    Created = 2,
    Running = 3,
    Completed = 4,
    Destroying = 5,
    Destroyed = 6,
    Failed = 7,
    Oomkilled = 8,
}
impl WorkloadState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "WORKLOAD_STATE_UNKNOWN",
            Self::Creating => "WORKLOAD_STATE_CREATING",
            Self::Created => "WORKLOAD_STATE_CREATED",
            Self::Running => "WORKLOAD_STATE_RUNNING",
            Self::Completed => "WORKLOAD_STATE_COMPLETED",
            Self::Destroying => "WORKLOAD_STATE_DESTROYING",
            Self::Destroyed => "WORKLOAD_STATE_DESTROYED",
            Self::Failed => "WORKLOAD_STATE_FAILED",
            Self::Oomkilled => "WORKLOAD_STATE_OOMKILLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKLOAD_STATE_UNKNOWN" => Some(Self::Unknown),
            "WORKLOAD_STATE_CREATING" => Some(Self::Creating),
            "WORKLOAD_STATE_CREATED" => Some(Self::Created),
            "WORKLOAD_STATE_RUNNING" => Some(Self::Running),
            "WORKLOAD_STATE_COMPLETED" => Some(Self::Completed),
            "WORKLOAD_STATE_DESTROYING" => Some(Self::Destroying),
            "WORKLOAD_STATE_DESTROYED" => Some(Self::Destroyed),
            "WORKLOAD_STATE_FAILED" => Some(Self::Failed),
            "WORKLOAD_STATE_OOMKILLED" => Some(Self::Oomkilled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HostCpuTopologyClass {
    Standard = 0,
    Performance = 1,
    Efficiency = 2,
}
impl HostCpuTopologyClass {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Standard => "HOST_CPU_TOPOLOGY_CLASS_STANDARD",
            Self::Performance => "HOST_CPU_TOPOLOGY_CLASS_PERFORMANCE",
            Self::Efficiency => "HOST_CPU_TOPOLOGY_CLASS_EFFICIENCY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HOST_CPU_TOPOLOGY_CLASS_STANDARD" => Some(Self::Standard),
            "HOST_CPU_TOPOLOGY_CLASS_PERFORMANCE" => Some(Self::Performance),
            "HOST_CPU_TOPOLOGY_CLASS_EFFICIENCY" => Some(Self::Efficiency),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OciImageFormat {
    Unknown = 0,
    Squashfs = 1,
    Erofs = 2,
    /// Tar and directory formats are not launchable, and are intended for internal images.
    Tar = 3,
    Directory = 4,
}
impl OciImageFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "OCI_IMAGE_FORMAT_UNKNOWN",
            Self::Squashfs => "OCI_IMAGE_FORMAT_SQUASHFS",
            Self::Erofs => "OCI_IMAGE_FORMAT_EROFS",
            Self::Tar => "OCI_IMAGE_FORMAT_TAR",
            Self::Directory => "OCI_IMAGE_FORMAT_DIRECTORY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OCI_IMAGE_FORMAT_UNKNOWN" => Some(Self::Unknown),
            "OCI_IMAGE_FORMAT_SQUASHFS" => Some(Self::Squashfs),
            "OCI_IMAGE_FORMAT_EROFS" => Some(Self::Erofs),
            "OCI_IMAGE_FORMAT_TAR" => Some(Self::Tar),
            "OCI_IMAGE_FORMAT_DIRECTORY" => Some(Self::Directory),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OciImageProgressPhase {
    Unknown = 0,
    Started = 1,
    Resolving = 2,
    Resolved = 3,
    ConfigDownload = 4,
    LayerDownload = 5,
    Assemble = 6,
    Pack = 7,
    Complete = 8,
}
impl OciImageProgressPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "OCI_IMAGE_PROGRESS_PHASE_UNKNOWN",
            Self::Started => "OCI_IMAGE_PROGRESS_PHASE_STARTED",
            Self::Resolving => "OCI_IMAGE_PROGRESS_PHASE_RESOLVING",
            Self::Resolved => "OCI_IMAGE_PROGRESS_PHASE_RESOLVED",
            Self::ConfigDownload => "OCI_IMAGE_PROGRESS_PHASE_CONFIG_DOWNLOAD",
            Self::LayerDownload => "OCI_IMAGE_PROGRESS_PHASE_LAYER_DOWNLOAD",
            Self::Assemble => "OCI_IMAGE_PROGRESS_PHASE_ASSEMBLE",
            Self::Pack => "OCI_IMAGE_PROGRESS_PHASE_PACK",
            Self::Complete => "OCI_IMAGE_PROGRESS_PHASE_COMPLETE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OCI_IMAGE_PROGRESS_PHASE_UNKNOWN" => Some(Self::Unknown),
            "OCI_IMAGE_PROGRESS_PHASE_STARTED" => Some(Self::Started),
            "OCI_IMAGE_PROGRESS_PHASE_RESOLVING" => Some(Self::Resolving),
            "OCI_IMAGE_PROGRESS_PHASE_RESOLVED" => Some(Self::Resolved),
            "OCI_IMAGE_PROGRESS_PHASE_CONFIG_DOWNLOAD" => Some(Self::ConfigDownload),
            "OCI_IMAGE_PROGRESS_PHASE_LAYER_DOWNLOAD" => Some(Self::LayerDownload),
            "OCI_IMAGE_PROGRESS_PHASE_ASSEMBLE" => Some(Self::Assemble),
            "OCI_IMAGE_PROGRESS_PHASE_PACK" => Some(Self::Pack),
            "OCI_IMAGE_PROGRESS_PHASE_COMPLETE" => Some(Self::Complete),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OciImageProgressLayerPhase {
    Unknown = 0,
    Waiting = 1,
    Downloading = 2,
    Downloaded = 3,
    Extracting = 4,
    Extracted = 5,
}
impl OciImageProgressLayerPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "OCI_IMAGE_PROGRESS_LAYER_PHASE_UNKNOWN",
            Self::Waiting => "OCI_IMAGE_PROGRESS_LAYER_PHASE_WAITING",
            Self::Downloading => "OCI_IMAGE_PROGRESS_LAYER_PHASE_DOWNLOADING",
            Self::Downloaded => "OCI_IMAGE_PROGRESS_LAYER_PHASE_DOWNLOADED",
            Self::Extracting => "OCI_IMAGE_PROGRESS_LAYER_PHASE_EXTRACTING",
            Self::Extracted => "OCI_IMAGE_PROGRESS_LAYER_PHASE_EXTRACTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OCI_IMAGE_PROGRESS_LAYER_PHASE_UNKNOWN" => Some(Self::Unknown),
            "OCI_IMAGE_PROGRESS_LAYER_PHASE_WAITING" => Some(Self::Waiting),
            "OCI_IMAGE_PROGRESS_LAYER_PHASE_DOWNLOADING" => Some(Self::Downloading),
            "OCI_IMAGE_PROGRESS_LAYER_PHASE_DOWNLOADED" => Some(Self::Downloaded),
            "OCI_IMAGE_PROGRESS_LAYER_PHASE_EXTRACTING" => Some(Self::Extracting),
            "OCI_IMAGE_PROGRESS_LAYER_PHASE_EXTRACTED" => Some(Self::Extracted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneDiskStatusDiskPurpose {
    Unknown = 0,
    Addons = 1,
    Scratch = 2,
}
impl ZoneDiskStatusDiskPurpose {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ZONE_DISK_STATUS_DISK_PURPOSE_UNKNOWN",
            Self::Addons => "ZONE_DISK_STATUS_DISK_PURPOSE_ADDONS",
            Self::Scratch => "ZONE_DISK_STATUS_DISK_PURPOSE_SCRATCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZONE_DISK_STATUS_DISK_PURPOSE_UNKNOWN" => Some(Self::Unknown),
            "ZONE_DISK_STATUS_DISK_PURPOSE_ADDONS" => Some(Self::Addons),
            "ZONE_DISK_STATUS_DISK_PURPOSE_SCRATCH" => Some(Self::Scratch),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetHostStatusRequest {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetHostStatusReply {
    #[prost(string, tag="1")]
    pub host_uuid: ::prost::alloc::string::String,
    #[prost(uint32, tag="2")]
    pub host_domid: u32,
    #[prost(string, tag="3")]
    pub protect_version: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub host_ipv4: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub host_ipv6: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub host_mac: ::prost::alloc::string::String,
    #[prost(uint64, optional, tag="7")]
    pub hyp_free_mem: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateZoneRequest {
    #[prost(message, optional, tag="1")]
    pub spec: ::core::option::Option<ZoneSpec>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateZoneReply {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DestroyZoneRequest {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DestroyZoneReply {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResolveZoneIdRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResolveZoneIdReply {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResolveZoneIdsRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResolveZoneIdsReply {
    #[prost(string, repeated, tag="1")]
    pub zone_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetZoneRequest {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetZoneReply {
    #[prost(message, optional, tag="1")]
    pub zone: ::core::option::Option<Zone>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListZonesRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesReply {
    #[prost(message, repeated, tag="1")]
    pub zones: ::prost::alloc::vec::Vec<Zone>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelEventStreamUpdate {
    #[prost(uint32, repeated, tag="2")]
    pub enabled_syscalls: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelEventStreamStop {
}
/// roughly maps to libscap's `scap_threadinfo` type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneKernelThreadInfo {
    #[prost(uint64, optional, tag="1")]
    pub tid: ::core::option::Option<u64>,
    /// threads ALWAYS have a pid(tgid) IRL - this is optional as shorthand for "fully vs partially constructed".
    #[prost(uint64, optional, tag="2")]
    pub pid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="3")]
    pub ptid: ::core::option::Option<u64>,
    #[prost(uint64, tag="4")]
    pub sid: u64,
    #[prost(uint64, tag="5")]
    pub vpgid: u64,
    #[prost(uint64, tag="6")]
    pub pgid: u64,
    #[prost(string, tag="7")]
    pub comm: ::prost::alloc::string::String,
    #[prost(string, tag="8")]
    pub exe: ::prost::alloc::string::String,
    #[prost(string, tag="9")]
    pub exepath: ::prost::alloc::string::String,
    #[prost(bool, tag="10")]
    pub exe_writable: bool,
    #[prost(bool, tag="11")]
    pub exe_upper_layer: bool,
    #[prost(bool, tag="12")]
    pub exe_lower_layer: bool,
    #[prost(bool, tag="13")]
    pub exe_from_memfd: bool,
    #[prost(string, tag="14")]
    pub args: ::prost::alloc::string::String,
    #[prost(string, tag="15")]
    pub env: ::prost::alloc::string::String,
    #[prost(string, tag="16")]
    pub cwd: ::prost::alloc::string::String,
    #[prost(int64, tag="17")]
    pub fdlimit: i64,
    #[prost(uint32, tag="18")]
    pub flags: u32,
    #[prost(uint32, tag="19")]
    pub uid: u32,
    #[prost(uint32, tag="20")]
    pub gid: u32,
    #[prost(uint64, tag="21")]
    pub cap_permitted: u64,
    #[prost(uint64, tag="22")]
    pub cap_effective: u64,
    #[prost(uint64, tag="23")]
    pub cap_inheritable: u64,
    #[prost(uint64, tag="24")]
    pub exe_ino: u64,
    #[prost(uint64, tag="25")]
    pub exe_ino_ctime: u64,
    #[prost(uint64, tag="26")]
    pub exe_ino_mtime: u64,
    #[prost(uint64, tag="27")]
    pub exe_ino_ctime_duration_clone_ts: u64,
    #[prost(uint64, tag="28")]
    pub exe_ino_ctime_duration_pidns_start: u64,
    #[prost(uint32, tag="29")]
    pub vmsize_kb: u32,
    #[prost(uint32, tag="30")]
    pub vmrss_kb: u32,
    #[prost(uint32, tag="31")]
    pub vmswap_kb: u32,
    #[prost(uint64, tag="32")]
    pub pfmajor: u64,
    #[prost(uint64, tag="33")]
    pub pfminor: u64,
    #[prost(uint64, optional, tag="34")]
    pub vtid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="35")]
    pub vpid: ::core::option::Option<u64>,
    #[prost(uint64, tag="36")]
    pub pidns_init_start_ts: u64,
    #[prost(string, tag="37")]
    pub cgroups: ::prost::alloc::string::String,
    #[prost(string, tag="38")]
    pub root: ::prost::alloc::string::String,
    #[prost(bool, tag="39")]
    pub filtered_out: bool,
    #[prost(map="uint64, message", tag="40")]
    pub fdlist: ::std::collections::HashMap<u64, ZoneKernelFdInfo>,
    #[prost(uint64, tag="41")]
    pub clone_ts: u64,
    #[prost(uint32, tag="42")]
    pub tty: u32,
    #[prost(uint32, tag="43")]
    pub loginuid: u32,
    #[prost(uint64, tag="44")]
    pub lastexec_ts: u64,
    #[prost(bool, tag="45")]
    pub reaper: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelFdInfo {
    /// unset fd id == invalid fd info
    #[prost(uint64, optional, tag="1")]
    pub fd: ::core::option::Option<u64>,
    #[prost(uint64, tag="2")]
    pub inode: u64,
    #[prost(enumeration="ZoneKernelFdType", tag="3")]
    pub fd_type: i32,
    #[prost(message, optional, tag="4")]
    pub info: ::core::option::Option<ZoneKernelFdInfoData>,
    /// these two are not typically set at capture time,
    /// but are updated at parse time.
    #[prost(uint32, tag="5")]
    pub open_flags: u32,
    #[prost(uint32, tag="6")]
    pub state_flags: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelFdInfoData {
    #[prost(oneof="zone_kernel_fd_info_data::InfoType", tags="1, 2, 3, 4, 5, 6, 7, 8")]
    pub info_type: ::core::option::Option<zone_kernel_fd_info_data::InfoType>,
}
/// Nested message and enum types in `ZoneKernelFdInfoData`.
pub mod zone_kernel_fd_info_data {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum InfoType {
        #[prost(message, tag="1")]
        Ipv4Socket(super::ZoneKernelIpv4SocketInfo),
        #[prost(message, tag="2")]
        Ipv6Socket(super::ZoneKernelIpv6SocketInfo),
        #[prost(message, tag="3")]
        Ipv4ServerSocket(super::ZoneKernelIpv4ServerSocketInfo),
        #[prost(message, tag="4")]
        Ipv6ServerSocket(super::ZoneKernelIpv6ServerSocketInfo),
        #[prost(message, tag="5")]
        UnixSocket(super::ZoneKernelUnixSocketInfo),
        #[prost(message, tag="6")]
        RegularFile(super::ZoneKernelRegularFileInfo),
        #[prost(string, tag="7")]
        FileName(::prost::alloc::string::String),
        #[prost(message, tag="8")]
        Pidfd(super::ZoneKernelPidFd),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelIpv4SocketInfo {
    /// IPv4 address as string
    #[prost(string, tag="1")]
    pub source_ip: ::prost::alloc::string::String,
    /// IPv4 address as string
    #[prost(string, tag="2")]
    pub dest_ip: ::prost::alloc::string::String,
    #[prost(uint32, tag="3")]
    pub source_port: u32,
    #[prost(uint32, tag="4")]
    pub dest_port: u32,
    #[prost(enumeration="ZoneKernelIpProtocol", tag="5")]
    pub protocol: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelIpv6SocketInfo {
    /// IPv6 address as string
    #[prost(string, tag="1")]
    pub source_ip: ::prost::alloc::string::String,
    /// IPv6 address as string
    #[prost(string, tag="2")]
    pub dest_ip: ::prost::alloc::string::String,
    #[prost(uint32, tag="3")]
    pub source_port: u32,
    #[prost(uint32, tag="4")]
    pub dest_port: u32,
    #[prost(enumeration="ZoneKernelIpProtocol", tag="5")]
    pub protocol: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelIpv4ServerSocketInfo {
    /// IPv4 address as string
    #[prost(string, tag="1")]
    pub local_ip: ::prost::alloc::string::String,
    #[prost(uint32, tag="2")]
    pub local_port: u32,
    #[prost(enumeration="ZoneKernelIpProtocol", tag="3")]
    pub protocol: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelIpv6ServerSocketInfo {
    /// IPv6 address as string
    #[prost(string, tag="1")]
    pub local_ip: ::prost::alloc::string::String,
    #[prost(uint32, tag="2")]
    pub local_port: u32,
    #[prost(enumeration="ZoneKernelIpProtocol", tag="3")]
    pub protocol: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelUnixSocketInfo {
    #[prost(uint64, tag="1")]
    pub source: u64,
    #[prost(uint64, tag="2")]
    pub destination: u64,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelRegularFileInfo {
    #[prost(uint32, tag="1")]
    pub open_flags: u32,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag="3")]
    pub mount_id: u32,
    #[prost(uint32, tag="4")]
    pub device: u32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelPidFd {
    #[prost(uint64, tag="1")]
    pub pid: u64,
}
/// Roughly maps to the Falco libscap format for generic events:
/// <https://falco.org/docs/reference/plugins/plugin-api-reference/#libscap-event-block-specification>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneKernelSyscallEvent {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub timestamp: u64,
    /// TODO BML possibly not needed for plugin events.
    #[prost(uint64, tag="3")]
    pub thread_id: u64,
    /// header + params
    #[prost(uint32, tag="4")]
    pub event_length: u32,
    #[prost(string, tag="5")]
    pub event_name: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub event_category: ::prost::alloc::string::String,
    /// Event flags (bitmask, see `ppm_evt_flags` in falcosecurity/libs/driver/ppm_events_public.h) - not part of the raw payload but contains helpful serialization hints.
    #[prost(uint32, tag="8")]
    pub event_flags: u32,
    /// Event type
    #[prost(uint32, tag="9")]
    pub event_type: u32,
    #[prost(uint32, tag="10")]
    pub cpuid: u32,
    #[prost(message, repeated, tag="7")]
    pub event_params: ::prost::alloc::vec::Vec<ZoneKernelEventParam>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneKernelThreadSnapshotEvent {
    #[prost(string, tag="2")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(map="uint64, message", tag="1")]
    pub thread_info: ::std::collections::HashMap<u64, ZoneKernelThreadInfo>,
    /// some thread info timestamp fields are relative to this
    #[prost(uint64, tag="3")]
    pub zone_boot_epoch: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MonitorZoneKernelEventRequest {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(oneof="monitor_zone_kernel_event_request::Request", tags="3, 4")]
    pub request: ::core::option::Option<monitor_zone_kernel_event_request::Request>,
}
/// Nested message and enum types in `MonitorZoneKernelEventRequest`.
pub mod monitor_zone_kernel_event_request {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag="3")]
        Update(super::ZoneKernelEventStreamUpdate),
        #[prost(message, tag="4")]
        Stop(super::ZoneKernelEventStreamStop),
    }
}
/// Note that `zone_id` is duplicated within each
/// reply type, and not simply defined once in the toplevel
/// message. This is intentional, as it makes bincoding the
/// internal reply types as bytes easier.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonitorZoneKernelEventReply {
    #[prost(oneof="monitor_zone_kernel_event_reply::Reply", tags="2, 3")]
    pub reply: ::core::option::Option<monitor_zone_kernel_event_reply::Reply>,
}
/// Nested message and enum types in `MonitorZoneKernelEventReply`.
pub mod monitor_zone_kernel_event_reply {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Reply {
        #[prost(message, tag="2")]
        Syscall(super::ZoneKernelSyscallEvent),
        #[prost(message, tag="3")]
        Threadsnap(super::ZoneKernelThreadSnapshotEvent),
    }
}
/// in libscap, events are packed on the wire accordingly:
/// - a header
/// - an arbitrary sequence of 2-or-4-byte numbers for each param, indicating param lengths
///    (4-bytes if `EF_LARGE_PAYLOAD` bitmask is set on `ppm_evt_flags`, otherwise 2)
/// - an arbitrary sequence of bytes for each param, encoding param data/values.
/// This represents the non-header parts of the event.
/// The number of paramters, as well as whether the param lengths are represented as 2 or 4 byte numbers,
/// is defined by the header in libscap, but for convenience those are colocated in this message here.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneKernelEventParam {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag="2")]
    pub param_type: u32,
    #[prost(bytes="vec", tag="3")]
    pub param_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="4")]
    pub param_pretty: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub param_type_pretty: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteZoneCommandRequest {
    #[prost(oneof="execute_zone_command_request::Request", tags="1, 2, 3")]
    pub request: ::core::option::Option<execute_zone_command_request::Request>,
}
/// Nested message and enum types in `ExecuteZoneCommandRequest`.
pub mod execute_zone_command_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag="1")]
        Start(super::ExecuteZoneCommandStart),
        #[prost(message, tag="2")]
        Stdin(super::ExecuteZoneCommandStdin),
        #[prost(message, tag="3")]
        TerminalResize(super::ExecuteZoneCommandTerminalResize),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteZoneCommandStart {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub workload_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub process: ::core::option::Option<ProcessSpec>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExecuteZoneCommandStdin {
    #[prost(bytes="vec", tag="1")]
    pub stdin: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag="2")]
    pub closed: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExecuteZoneCommandTerminalResize {
    #[prost(message, optional, tag="1")]
    pub size: ::core::option::Option<TerminalSize>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExecuteZoneCommandOutput {
    #[prost(bytes="vec", tag="1")]
    pub stdout: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub stderr: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExecuteZoneCommandExited {
    #[prost(int32, tag="1")]
    pub exit_code: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExecuteZoneCommandReply {
    #[prost(oneof="execute_zone_command_reply::Reply", tags="1, 2")]
    pub reply: ::core::option::Option<execute_zone_command_reply::Reply>,
}
/// Nested message and enum types in `ExecuteZoneCommandReply`.
pub mod execute_zone_command_reply {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Reply {
        #[prost(message, tag="1")]
        Output(super::ExecuteZoneCommandOutput),
        #[prost(message, tag="2")]
        Exited(super::ExecuteZoneCommandExited),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneConsoleRequest {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag="3")]
    pub replay_history: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZoneConsoleReply {
    #[prost(bytes="vec", tag="1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkloadConsoleRequest {
    #[prost(string, tag="1")]
    pub workload_id: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="2")]
    pub stdin: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag="3")]
    pub stdin_closed: bool,
    #[prost(message, optional, tag="4")]
    pub terminal_resize: ::core::option::Option<TerminalSize>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkloadConsoleReply {
    #[prost(bytes="vec", tag="1")]
    pub stdout: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub stderr: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WatchEventsRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchEventsReply {
    #[prost(oneof="watch_events_reply::Event", tags="1, 2")]
    pub event: ::core::option::Option<watch_events_reply::Event>,
}
/// Nested message and enum types in `WatchEventsReply`.
pub mod watch_events_reply {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag="1")]
        ZoneChanged(super::ZoneChangedEvent),
        #[prost(message, tag="2")]
        WorkloadChanged(super::WorkloadChangedEvent),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneChangedEvent {
    #[prost(message, optional, tag="1")]
    pub zone: ::core::option::Option<Zone>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadChangedEvent {
    #[prost(message, optional, tag="1")]
    pub workload: ::core::option::Option<Workload>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadZoneMetricsRequest {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadZoneMetricsReply {
    #[prost(message, optional, tag="1")]
    pub root: ::core::option::Option<MetricNode>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SnoopIdmRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnoopIdmReply {
    #[prost(message, repeated, tag="1")]
    pub packets: ::prost::alloc::vec::Vec<SnoopIdmPacket>,
    #[prost(uint64, tag="2")]
    pub skipped: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SnoopIdmPacket {
    #[prost(string, tag="1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub to: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="3")]
    pub packet: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PullImageRequest {
    #[prost(string, tag="1")]
    pub image: ::prost::alloc::string::String,
    #[prost(enumeration="OciImageFormat", tag="2")]
    pub format: i32,
    #[prost(bool, tag="3")]
    pub overwrite_cache: bool,
    #[prost(bool, tag="4")]
    pub update: bool,
    #[prost(bool, tag="5")]
    pub want_metadata: bool,
    #[prost(message, optional, tag="6")]
    pub auth: ::core::option::Option<OciRegistryAuthentication>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullImageReply {
    #[prost(message, optional, tag="1")]
    pub progress: ::core::option::Option<OciImageProgress>,
    #[prost(message, optional, tag="2")]
    pub spec: ::core::option::Option<OciImageSpec>,
    #[prost(message, optional, tag="3")]
    pub metadata: ::core::option::Option<OciImageMetadata>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportImageRequest {
    #[prost(string, tag="1")]
    pub digest: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub image: ::prost::alloc::string::String,
    #[prost(enumeration="OciImageFormat", tag="3")]
    pub format: i32,
    #[prost(bytes="vec", tag="4")]
    pub chunk: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag="5")]
    pub last_chunk: bool,
    #[prost(bool, tag="6")]
    pub overwrite_cache: bool,
    #[prost(bool, tag="7")]
    pub want_metadata: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportImageReply {
    #[prost(bool, tag="1")]
    pub accepted: bool,
    #[prost(message, optional, tag="2")]
    pub progress: ::core::option::Option<OciImageProgress>,
    #[prost(message, optional, tag="3")]
    pub spec: ::core::option::Option<OciImageSpec>,
    #[prost(message, optional, tag="4")]
    pub metadata: ::core::option::Option<OciImageMetadata>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoveImageRequest {
    #[prost(string, tag="1")]
    pub digest: ::prost::alloc::string::String,
    #[prost(enumeration="OciImageFormat", tag="2")]
    pub format: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoveImageReply {
    #[prost(bool, tag="1")]
    pub removed: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListImagesRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImagesReply {
    #[prost(message, repeated, tag="1")]
    pub images: ::prost::alloc::vec::Vec<OciImageInfo>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDevicesRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDevicesReply {
    #[prost(message, repeated, tag="1")]
    pub devices: ::prost::alloc::vec::Vec<DeviceInfo>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetHostCpuTopologyRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHostCpuTopologyReply {
    #[prost(message, repeated, tag="1")]
    pub cpus: ::prost::alloc::vec::Vec<HostCpuTopologyInfo>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetHostPowerManagementPolicyRequest {
    #[prost(string, tag="1")]
    pub scheduler: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub smt_awareness: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetHostPowerManagementPolicyReply {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateZoneResourcesRequest {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub resources: ::core::option::Option<ZoneResourcesSpec>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateZoneResourcesReply {
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadHypervisorConsoleRequest {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadHypervisorConsoleReply {
    #[prost(string, tag="1")]
    pub data: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListNetworkReservationsRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkReservationsReply {
    #[prost(message, repeated, tag="1")]
    pub reservations: ::prost::alloc::vec::Vec<NetworkReservation>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateNetworkReservationRequest {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateNetworkReservationReply {
    #[prost(message, optional, tag="1")]
    pub reservation: ::core::option::Option<NetworkReservation>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DestroyNetworkReservationRequest {
    #[prost(string, tag="1")]
    pub reservation_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DestroyNetworkReservationReply {
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HypervisorDebugInfoRequest {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HypervisorDebugInfoReply {
    #[prost(string, tag="1")]
    pub json: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkloadRequest {
    #[prost(message, optional, tag="1")]
    pub spec: ::core::option::Option<WorkloadSpec>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateWorkloadReply {
    #[prost(string, tag="1")]
    pub workload_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StartWorkloadRequest {
    #[prost(string, tag="1")]
    pub workload_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StartWorkloadReply {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StopWorkloadRequest {
    #[prost(string, tag="1")]
    pub workload_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub timeout: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StopWorkloadReply {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DestroyWorkloadRequest {
    #[prost(string, tag="1")]
    pub workload_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DestroyWorkloadReply {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResolveWorkloadIdRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResolveWorkloadIdReply {
    #[prost(string, tag="1")]
    pub workload_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResolveWorkloadIdsRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResolveWorkloadIdsReply {
    #[prost(string, repeated, tag="1")]
    pub workload_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListWorkloadsRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkloadsReply {
    #[prost(message, repeated, tag="1")]
    pub workloads: ::prost::alloc::vec::Vec<Workload>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetWorkloadRequest {
    #[prost(string, tag="1")]
    pub workload_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkloadReply {
    #[prost(message, optional, tag="1")]
    pub workload: ::core::option::Option<Workload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureZoneNetworkRequest {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<ZoneNetworkConfig>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConfigureZoneNetworkReply {
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DialNetworkSocketRequest {
    #[prost(oneof="dial_network_socket_request::Request", tags="1, 2")]
    pub request: ::core::option::Option<dial_network_socket_request::Request>,
}
/// Nested message and enum types in `DialNetworkSocketRequest`.
pub mod dial_network_socket_request {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag="1")]
        Start(super::DialNetworkSocketStart),
        #[prost(message, tag="2")]
        Data(super::DialNetworkSocketData),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DialNetworkSocketStart {
    #[prost(string, tag="1")]
    pub zone_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag="3")]
    pub port: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DialNetworkSocketData {
    #[prost(bytes="vec", tag="1")]
    pub content: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DialNetworkSocketReply {
    #[prost(message, optional, tag="1")]
    pub data: ::core::option::Option<DialNetworkSocketData>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneKernelFdType {
    Unknown = 0,
    File = 1,
    Directory = 2,
    Ipv4Sock = 3,
    Ipv6Sock = 4,
    Ipv4Servsock = 5,
    Ipv6Servsock = 6,
    Fifo = 7,
    UnixSock = 8,
    Event = 9,
    Unsupported = 10,
    Signalfd = 11,
    Eventpoll = 12,
    Inotify = 13,
    Timerfd = 14,
    Netlink = 15,
    FileV2 = 16,
    Bpf = 17,
    Userfaultfd = 18,
    Iouring = 19,
    Memfd = 20,
    Pidfd = 21,
}
impl ZoneKernelFdType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ZONE_KERNEL_FD_TYPE_UNKNOWN",
            Self::File => "ZONE_KERNEL_FD_TYPE_FILE",
            Self::Directory => "ZONE_KERNEL_FD_TYPE_DIRECTORY",
            Self::Ipv4Sock => "ZONE_KERNEL_FD_TYPE_IPV4_SOCK",
            Self::Ipv6Sock => "ZONE_KERNEL_FD_TYPE_IPV6_SOCK",
            Self::Ipv4Servsock => "ZONE_KERNEL_FD_TYPE_IPV4_SERVSOCK",
            Self::Ipv6Servsock => "ZONE_KERNEL_FD_TYPE_IPV6_SERVSOCK",
            Self::Fifo => "ZONE_KERNEL_FD_TYPE_FIFO",
            Self::UnixSock => "ZONE_KERNEL_FD_TYPE_UNIX_SOCK",
            Self::Event => "ZONE_KERNEL_FD_TYPE_EVENT",
            Self::Unsupported => "ZONE_KERNEL_FD_TYPE_UNSUPPORTED",
            Self::Signalfd => "ZONE_KERNEL_FD_TYPE_SIGNALFD",
            Self::Eventpoll => "ZONE_KERNEL_FD_TYPE_EVENTPOLL",
            Self::Inotify => "ZONE_KERNEL_FD_TYPE_INOTIFY",
            Self::Timerfd => "ZONE_KERNEL_FD_TYPE_TIMERFD",
            Self::Netlink => "ZONE_KERNEL_FD_TYPE_NETLINK",
            Self::FileV2 => "ZONE_KERNEL_FD_TYPE_FILE_V2",
            Self::Bpf => "ZONE_KERNEL_FD_TYPE_BPF",
            Self::Userfaultfd => "ZONE_KERNEL_FD_TYPE_USERFAULTFD",
            Self::Iouring => "ZONE_KERNEL_FD_TYPE_IOURING",
            Self::Memfd => "ZONE_KERNEL_FD_TYPE_MEMFD",
            Self::Pidfd => "ZONE_KERNEL_FD_TYPE_PIDFD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZONE_KERNEL_FD_TYPE_UNKNOWN" => Some(Self::Unknown),
            "ZONE_KERNEL_FD_TYPE_FILE" => Some(Self::File),
            "ZONE_KERNEL_FD_TYPE_DIRECTORY" => Some(Self::Directory),
            "ZONE_KERNEL_FD_TYPE_IPV4_SOCK" => Some(Self::Ipv4Sock),
            "ZONE_KERNEL_FD_TYPE_IPV6_SOCK" => Some(Self::Ipv6Sock),
            "ZONE_KERNEL_FD_TYPE_IPV4_SERVSOCK" => Some(Self::Ipv4Servsock),
            "ZONE_KERNEL_FD_TYPE_IPV6_SERVSOCK" => Some(Self::Ipv6Servsock),
            "ZONE_KERNEL_FD_TYPE_FIFO" => Some(Self::Fifo),
            "ZONE_KERNEL_FD_TYPE_UNIX_SOCK" => Some(Self::UnixSock),
            "ZONE_KERNEL_FD_TYPE_EVENT" => Some(Self::Event),
            "ZONE_KERNEL_FD_TYPE_UNSUPPORTED" => Some(Self::Unsupported),
            "ZONE_KERNEL_FD_TYPE_SIGNALFD" => Some(Self::Signalfd),
            "ZONE_KERNEL_FD_TYPE_EVENTPOLL" => Some(Self::Eventpoll),
            "ZONE_KERNEL_FD_TYPE_INOTIFY" => Some(Self::Inotify),
            "ZONE_KERNEL_FD_TYPE_TIMERFD" => Some(Self::Timerfd),
            "ZONE_KERNEL_FD_TYPE_NETLINK" => Some(Self::Netlink),
            "ZONE_KERNEL_FD_TYPE_FILE_V2" => Some(Self::FileV2),
            "ZONE_KERNEL_FD_TYPE_BPF" => Some(Self::Bpf),
            "ZONE_KERNEL_FD_TYPE_USERFAULTFD" => Some(Self::Userfaultfd),
            "ZONE_KERNEL_FD_TYPE_IOURING" => Some(Self::Iouring),
            "ZONE_KERNEL_FD_TYPE_MEMFD" => Some(Self::Memfd),
            "ZONE_KERNEL_FD_TYPE_PIDFD" => Some(Self::Pidfd),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneKernelIpProtocol {
    Unknown = 0,
    Na = 1,
    Tcp = 2,
    Udp = 3,
    Icmp = 4,
    Raw = 5,
}
impl ZoneKernelIpProtocol {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ZONE_KERNEL_IP_PROTOCOL_UNKNOWN",
            Self::Na => "ZONE_KERNEL_IP_PROTOCOL_NA",
            Self::Tcp => "ZONE_KERNEL_IP_PROTOCOL_TCP",
            Self::Udp => "ZONE_KERNEL_IP_PROTOCOL_UDP",
            Self::Icmp => "ZONE_KERNEL_IP_PROTOCOL_ICMP",
            Self::Raw => "ZONE_KERNEL_IP_PROTOCOL_RAW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZONE_KERNEL_IP_PROTOCOL_UNKNOWN" => Some(Self::Unknown),
            "ZONE_KERNEL_IP_PROTOCOL_NA" => Some(Self::Na),
            "ZONE_KERNEL_IP_PROTOCOL_TCP" => Some(Self::Tcp),
            "ZONE_KERNEL_IP_PROTOCOL_UDP" => Some(Self::Udp),
            "ZONE_KERNEL_IP_PROTOCOL_ICMP" => Some(Self::Icmp),
            "ZONE_KERNEL_IP_PROTOCOL_RAW" => Some(Self::Raw),
            _ => None,
        }
    }
}
include!("protect.control.v1.serde.rs");
include!("protect.control.v1.tonic.rs");
// @@protoc_insertion_point(module)